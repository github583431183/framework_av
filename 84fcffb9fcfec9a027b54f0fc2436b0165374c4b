{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ddda6ed5_a5004466",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2021-10-27T18:01:28Z",
      "side": 1,
      "message": "Adding Jean-Michel as a reviewer, Eric as CC.",
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c800e31_9fdf9a63",
        "filename": "media/libaudioclient/AudioTrack.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2449,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2021-10-27T18:00:47Z",
      "side": 1,
      "message": "I believe a buffer level estimate is still needed for TRANSFER_SYNC_NOTIF_CALLBACK. Off the top of my head, a simple fix is either we mutex the obtainBuffer in AudioTrackShared (prefer not to given that we want to avoid mutexes in this logic) or we issue a nonblocking request for NOTIF_CALLBACK (with some wait timing done here).  Jean-Michel did the logic for TRANSFER_SYNC_NOTIF_CALLBACK so probably could comment better.\n\nhttps://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/jni/android_media_AudioTrack.cpp;l\u003d168",
      "range": {
        "startLine": 2449,
        "startChar": 0,
        "endLine": 2449,
        "endChar": 56
      },
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e974a165_cf776ab3",
        "filename": "media/libaudioclient/AudioTrack.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2449,
      "author": {
        "id": 1902032
      },
      "writtenOn": "2021-10-28T01:53:35Z",
      "side": 1,
      "message": "I check the logic of TRANSFER_SYNC_NOTIF_CALLBACK, I thought it only want to notice the AudioTrack.java can write more data, so it no need call obtainBuffer. and I agree with that should not mutex the obtainBuffer. however as you said, Jean-Michel did the logic, so please Jean-Michel confirm this, thanks.",
      "parentUuid": "0c800e31_9fdf9a63",
      "range": {
        "startLine": 2449,
        "startChar": 0,
        "endLine": 2449,
        "endChar": 56
      },
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "75261b1d_96fc926a",
        "filename": "media/libaudioclient/AudioTrack.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2449,
      "author": {
        "id": 1003259
      },
      "writtenOn": "2021-12-02T10:27:04Z",
      "side": 1,
      "message": "If you don\u0027t call obtain buffer, I would you block until room is available for the next write before you call the callback with EVENT_CAN_WRITE_MORE_DATA?\nAlso I don\u0027t understand how the callback is called if \"avail\" is forced to 0 due to the test at line 2473? mRemainingFrames will never be decremented and we will always exit at line 2500",
      "parentUuid": "e974a165_cf776ab3",
      "range": {
        "startLine": 2449,
        "startChar": 0,
        "endLine": 2449,
        "endChar": 56
      },
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "64f304e2_beb162b1",
        "filename": "media/libaudioclient/AudioTrack.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2449,
      "author": {
        "id": 1902032
      },
      "writtenOn": "2021-12-02T11:32:52Z",
      "side": 1,
      "message": "This callback is triggered by line 895 when offload mode with mTranser is TRANSFER_SYNC_NOTIF_CALLBACK.\nWhen the mTransfer mode is TRANSFER_SYNC_NOTIF_CALLBACK, this callback thread will always exit at line 2528 and will block until next AudioTrack::write is finished. And mRetryOnPartialBuffer will never get chance to set as true. so it will not exit at line 2500.",
      "parentUuid": "75261b1d_96fc926a",
      "range": {
        "startLine": 2449,
        "startChar": 0,
        "endLine": 2449,
        "endChar": 56
      },
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "46b42d3c_8d7eda04",
        "filename": "media/libaudioclient/AudioTrack.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2449,
      "author": {
        "id": 1003259
      },
      "writtenOn": "2021-12-02T13:20:10Z",
      "side": 1,
      "message": "We need at least to set audioBuffer.size because the JNI does not read audioBuffer.frameCount and the value passed to the app via onDataRequest will be uninitialized.\nAlso nothing guaranties that next time write completes and this method is called again room will be available if we do not call obtainBuffer. So will will call again onDataRequest() with size \u003d\u003d 0 and nothing guaranties the app will write again which will make that we never come back here again.",
      "parentUuid": "64f304e2_beb162b1",
      "range": {
        "startLine": 2449,
        "startChar": 0,
        "endLine": 2449,
        "endChar": 56
      },
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e4e94d3_703c822c",
        "filename": "media/libaudioclient/AudioTrack.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2449,
      "author": {
        "id": 1902032
      },
      "writtenOn": "2021-12-03T02:25:24Z",
      "side": 1,
      "message": "Thanks for your reply.\nCan we add lock to guarantee the obtainBuffer not access by two thread?\nIf not, the CTS case AudioTrackOffloadTest should call the first of the AudioTrack.write after the onDataRequest\u0027s size \u003e 0.\nAnd all the third party app which use the AudioTrack.java\u0027s offload mode need follow this design, or they may meet the block issue.",
      "parentUuid": "46b42d3c_8d7eda04",
      "range": {
        "startLine": 2449,
        "startChar": 0,
        "endLine": 2449,
        "endChar": 56
      },
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08f62517_29f65f58",
        "filename": "media/libaudioclient/AudioTrack.cpp",
        "patchSetId": 2
      },
      "lineNbr": 2449,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2021-12-03T06:41:46Z",
      "side": 1,
      "message": "TBH, I am not keen with a special lock on obtainBuffer() as I mentioned before.  It will mean that the callback thread is stalled for write and the write is stalled for the callback.  So long as the write and callback are on the same thread (typical model), this is not material.  Yet, I don\u0027t like extra mutexes.\n\nI would rather use a non-blocking obtainBuffer().  Another approach, perhaps better, is to change the FUTEX_WAKE to wake more than one thread. I believe this is important anyways in case the client calls write() after a stop() - there will be contention for the futex between the notification thread and the caller write thread.  Change the value of (1) here to INT_MAX.\n\nhttps://cs.android.com/android/platform/superproject/+/master:frameworks/av/media/libaudioclient/AudioTrackShared.cpp;drc\u003d63a3583a3b22bdbb4fbc4a6a707185ff4da86179;l\u003d412\n\nhttps://cs.android.com/android/platform/superproject/+/master:frameworks/av/media/libaudioclient/AudioTrackShared.cpp;drc\u003d63a3583a3b22bdbb4fbc4a6a707185ff4da86179;l\u003d422\n\nhttps://cs.android.com/android/platform/superproject/+/master:frameworks/av/media/libaudioclient/AudioTrackShared.cpp;drc\u003d63a3583a3b22bdbb4fbc4a6a707185ff4da86179;l\u003d750\n\nPerhaps that might be the right way to go.  I don\u0027t know whether this works properly in all cases, but maybe this is more promising.",
      "parentUuid": "4e4e94d3_703c822c",
      "range": {
        "startLine": 2449,
        "startChar": 0,
        "endLine": 2449,
        "endChar": 56
      },
      "revId": "84fcffb9fcfec9a027b54f0fc2436b0165374c4b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}