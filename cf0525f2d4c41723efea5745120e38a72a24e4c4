{
  "comments": [
    {
      "key": {
        "uuid": "N556qmXE",
        "filename": "media/libstagefright/AwesomePlayer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2028,
      "author": {
        "id": 1017178
      },
      "writtenOn": "2013-01-08T09:45:57Z",
      "side": 1,
      "message": "The Mutex is already unlocked when connection so there seems to be \nno point in adding mConnectingDataSource.disconnect() outside of the mutex\nin reset() and it is already present inside of the mutex.\n\nWhen reset_l() aborts the connection and this function returns an error it\nwill call abortPrepare that signals the preparedcondition so that reset_l can finish.",
      "revId": "cf0525f2d4c41723efea5745120e38a72a24e4c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "N4KiVX6I",
        "filename": "media/libstagefright/AwesomePlayer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2028,
      "author": {
        "id": 1015362
      },
      "writtenOn": "2013-01-08T10:15:32Z",
      "side": 1,
      "message": "Yes, what you explain is right. But this mConnectingDataSource.disconnect() is not just for interrupt  mConnectingDataSource-\u003econnect(mUri, \u0026mUriHeaders), also for other things.  For example, requesting enough data to establish extractor or meta data and so on, when these are blocked, other calling cannot acquire the lock. So add another way to interrupt from the \"mConnectingDataSource\" , make the blocking calls return err and other calling can  acquire the lock.",
      "parentUuid": "N556qmXE",
      "revId": "cf0525f2d4c41723efea5745120e38a72a24e4c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "N574q9ec",
        "filename": "media/libstagefright/AwesomePlayer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2028,
      "author": {
        "id": 1017178
      },
      "writtenOn": "2013-01-08T10:30:38Z",
      "side": 1,
      "message": "OK, by not clearing mConnectingDataSource after its use you are keeping a reference to the internal http source of NuCachedSource and can interrupt it at any time.",
      "parentUuid": "N4KiVX6I",
      "revId": "cf0525f2d4c41723efea5745120e38a72a24e4c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "N536s7TY",
        "filename": "media/libstagefright/AwesomePlayer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2028,
      "author": {
        "id": 1017178
      },
      "writtenOn": "2013-01-08T12:03:44Z",
      "side": 1,
      "message": "Though NuCachedsource will not return an error on disconnect,\nit will try to reconnect first and any read blocking from within a mutex in awesomeplayer will only get released once it is ready.\n\nSee NuCachedSource::ReadInternal",
      "parentUuid": "N574q9ec",
      "revId": "cf0525f2d4c41723efea5745120e38a72a24e4c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "N94tt7fs",
        "filename": "media/libstagefright/AwesomePlayer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 2028,
      "author": {
        "id": 1015362
      },
      "writtenOn": "2013-01-09T02:47:23Z",
      "side": 1,
      "message": "How do you think this \"reconnect\" after you click \"BACK\" key while it is blocked in reading?",
      "parentUuid": "N536s7TY",
      "revId": "cf0525f2d4c41723efea5745120e38a72a24e4c4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}