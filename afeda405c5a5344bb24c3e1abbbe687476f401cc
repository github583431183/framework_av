{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "78a2ac06_76f490b5",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessing.cpp",
        "patchSetId": 5
      },
      "lineNbr": 268,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2023-03-23T18:18:38Z",
      "side": 1,
      "message": "I\u0027m trying to understand why use of generated comparison operators for these parcelables does not work. Our definition of `isInLimits(x, a, b)` is `a \u003c\u003d x \u0026\u0026 x \u003c\u003d b`. When there are multiple fields, for example, two: f1 and f2, our check effectively does this:\n\n```\n    !(!isInLimits(s.f1, low.f1, high.f1) || !isInLimits(s.f2, low.f2, high.f2))\n\u003c\u003d\u003e isInLimits(s.f1, low.f1, high.f1) \u0026\u0026 isInLimits(s.f2, low.f2, high.f2)\n\u003c\u003d\u003e (low.f1 \u003c\u003d s.f1 \u0026\u0026 s.f1 \u003c\u003d high.f1) \u0026\u0026 (low.f2 \u003c\u003d s.f2 \u0026\u0026 s.f2 \u003c\u003d high.f2)\n\u003c\u003d\u003e (low.f1 \u003c\u003d s.f1 \u0026\u0026 low.f2 \u003c\u003d s.f2) \u0026\u0026 (s.f1 \u003c\u003d f1high \u0026\u0026 f2 \u003c\u003d f2high)\n\u003c\u003d\u003e low \u003c\u003d s \u0026\u0026 s \u003c\u003d high\n```\n\nBecause lexicographical comparison goes field by field (https://en.cppreference.com/w/cpp/utility/tuple/tie#Example).\n\nI remember on a meeting you had some example where these autogenerated parcelable comparisons can\u0027t be usedâ€”could you please point it out?",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 268,
        "endChar": 5
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdf04a37_d000e8bb",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessing.cpp",
        "patchSetId": 5
      },
      "lineNbr": 268,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2023-03-23T19:15:26Z",
      "side": 1,
      "message": "Sorry, I probably got the definition of the lexicographical order wrong. If we consider `124 \u003c 134`, that\u0027s because `1 \u003c 1 \u003d\u003d f, 2 \u003c 3 \u003d\u003d t` so it\u0027s a logical OR operation, not AND. But I think we can still use generated comparators:\n\n```\n...\n    (low.f1 \u003c\u003d s.f1 \u0026\u0026 low.f2 \u003c\u003d s.f2) \u0026\u0026 (s.f1 \u003c\u003d f1.high \u0026\u0026 f2 \u003c\u003d f2.high)\n\u003c\u003d\u003e !(!(low.f1 \u003c\u003d s.f1 \u0026\u0026 low.f2 \u003c\u003d s.f2) || !(s.f1 \u003c\u003d f1.high \u0026\u0026 f2 \u003c\u003d f2.high))\n\u003c\u003d\u003e !((low.f1 \u003e s.f1 || low.f2 \u003e s.f2) || (s.f1 \u003e f1.high || f2 \u003e f2.high))\n\u003c\u003d\u003e !(low \u003e s || s \u003e high)\n```\n\nThus, in this case, it should be `if (min \u003e cfg || cfg \u003e max) return false`",
      "parentUuid": "78a2ac06_76f490b5",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 268,
        "endChar": 5
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7a560a7_0c59b703",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessing.cpp",
        "patchSetId": 5
      },
      "lineNbr": 268,
      "author": {
        "id": 1956242
      },
      "writtenOn": "2023-03-23T22:40:08Z",
      "side": 1,
      "message": "I\u0027m afraid we can use generated parcelable comparison operators for some structures directly, take the ChannelConfig as example:\n```\n    parcelable ChannelConfig {\n        int channel;\n        boolean enable;\n    }\n```\n\nIf we have:\n```\nmin \u003d {.channel \u003d 0, .enable \u003d false};\nmax \u003d {.channel \u003d 5, .enable \u003d false};\ntarget \u003d {.channel \u003d 3, .enable \u003d true}; // should be out of range because `enable` field should not exceed max (false).\n```\n\nWhat we want with min/max is: the channel ID valid range is [0, 5] and the enable field valid range is [false, false], but in this case target will be in range of [min, max] with generated parcelable comparison, because the std::tie comparison will follow the lexicographical order and just skip the `.enable` field.\nLet me know if this make sense.",
      "parentUuid": "cdf04a37_d000e8bb",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 268,
        "endChar": 5
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2bcdad2_0506d60c",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessing.cpp",
        "patchSetId": 5
      },
      "lineNbr": 268,
      "author": {
        "id": 1956242
      },
      "writtenOn": "2023-03-23T22:41:42Z",
      "side": 1,
      "message": "Sorry I meant \"we can NOT use generated parcelable comparison operators\"",
      "parentUuid": "b7a560a7_0c59b703",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 268,
        "endChar": 5
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "706ba857_330918e9",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessing.cpp",
        "patchSetId": 5
      },
      "lineNbr": 268,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2023-03-24T00:05:27Z",
      "side": 1,
      "message": "OK, I see the problem. However, we don\u0027t have to hand-roll checks for each structure in order to solve it. The only thing we need is a tuple with pointers to the fields, everything else can be generated using templates. Please consider this example implementation (https://godbolt.org/z/49b17K19r):\n\n```\n#include \u003ctuple\u003e\n\nstruct St {\n    int a;\n    float f;\n    bool b;\n};\n\ntemplate\u003ctypename P, typename S, std::size_t I\u003d0\u003e  // P is a tuple of field pointers for S\nbool eachMemberLessOrEqual(const P\u0026 p, const S\u0026 a, const S\u0026 b) {\n    if constexpr (I \u003e\u003d std::tuple_size_v\u003cP\u003e) { \n        return true;\n    } else {\n        auto fieldPtr \u003d std::get\u003cI\u003e(p);\n        return (a.*fieldPtr \u003c\u003d b.*fieldPtr) \u0026\u0026 eachMemberLessOrEqual\u003cP, S, I+1\u003e(p, a, b);\n    }\n}\n\ntemplate\u003ctypename P, typename S\u003e\nbool isInRange(const P\u0026 p, const S\u0026 s, const S\u0026 min, const S\u0026 max) {\n    return eachMemberLessOrEqual(p, min, s) \u0026\u0026 eachMemberLessOrEqual(p, s, max); \n}\n\nstatic constexpr auto kStFields \u003d std::make_tuple(\u0026St::a, \u0026St::f, \u0026St::b);\n\nint main(int, char**, char**) {\n    const St min{0, 0.0, false};\n    const St max{5, 10.0, false};\n    const St outOfRange{3, 5.0, true};\n    const St inRange{3, 5.0, false};\n    return isInRange(kStFields, outOfRange, min, max);  // false\n    //return isInRange(kStFields, inRange, min, max);  // true\n}\n```",
      "parentUuid": "a2bcdad2_0506d60c",
      "range": {
        "startLine": 265,
        "startChar": 0,
        "endLine": 268,
        "endChar": 5
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3dfcacf6_3fc4d7c2",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessing.h",
        "patchSetId": 5
      },
      "lineNbr": 60,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2023-03-23T18:18:38Z",
      "side": 1,
      "message": "If we name it \"isInRange\", this will be consistent with the names for particular parameter checks.",
      "range": {
        "startLine": 60,
        "startChar": 9,
        "endLine": 60,
        "endChar": 19
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a566eb8_5941d935",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessingContext.cpp",
        "patchSetId": 5
      },
      "lineNbr": 439,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2023-03-23T18:18:38Z",
      "side": 1,
      "message": "These two functions probably can be defined using one template.",
      "range": {
        "startLine": 417,
        "startChar": 0,
        "endLine": 439,
        "endChar": 1
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e066819_871175ec",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessingContext.cpp",
        "patchSetId": 5
      },
      "lineNbr": 535,
      "author": {
        "id": 1956242
      },
      "writtenOn": "2023-03-23T22:40:08Z",
      "side": 1,
      "message": "If we put the range check inside `setLimiter`, we need to check the return code here. Same for other setters.",
      "range": {
        "startLine": 535,
        "startChar": 12,
        "endLine": 535,
        "endChar": 26
      },
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a7210d2_99d6c2b4",
        "filename": "media/libeffects/dynamicsproc/aidl/DynamicsProcessingContext.h",
        "patchSetId": 5
      },
      "lineNbr": 1,
      "author": {
        "id": 1956242
      },
      "writtenOn": "2023-03-23T22:40:08Z",
      "side": 1,
      "message": "remove the empty line, same for other files",
      "revId": "afeda405c5a5344bb24c3e1abbbe687476f401cc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}