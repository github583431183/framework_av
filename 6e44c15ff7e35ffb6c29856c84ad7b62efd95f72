{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1c19a5f9_a5c7567e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1234492
      },
      "writtenOn": "2022-07-07T04:20:35Z",
      "side": 1,
      "message": "- issue tracker:\n\nhttps://partnerissuetracker.corp.google.com/u/3/issues/237997490\n\n- analysis\n\nThe issue is draw defect in gallery with thumbnail of video. Copied from internal discussion:\n\nSection 5.11 of the GLSL ES spec includes:\n\n5.11 Evaluation of Expressions\n\nThe C++ standard requires that expressions must be evaluated in the order specified by the precedence of operations and may only be regrouped if the result is the same or where the result is undefined. No other transforms may be applied that affect the result of an operation. GLSL ES relaxes these requirements in the following ways:\n\n• Addition and multiplication are assumed to be associative.\n• Multiplication may be replaced by repeated addition\n• Floating point division may be replaced by reciprocal and multiplication:\n• Within the constraints of invariance (where applicable), the precision used may vary.\n\n\nThe associate multiplies below accords to the spec.\n\nexample:\n float nits;\n float slope \u003d (y1 - y0) / (x1 - x0);\n nits \u003d y0 + (nits - x0) * slope;\n\n\nA \u003d (y1 - y0)\nB \u003d (x1 - x0)\nC \u003d (nits - x0)\n\nOriginal:\nnits \u003d y0 + C * (A / B)\n\ndivision \u003d\u003e recip + mul\nnits \u003d y0 + C * (A * (1 / B))\n\nre-associate multiplies:\nnits \u003d y0 + (C * A) * (1 / B)\n\nAs you can see, C * A could exceed the float maximal number. It converts to float nits would cause incorrect value.\n",
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "99d9d31e_9170995f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1234492
      },
      "writtenOn": "2022-07-07T04:38:57Z",
      "side": 1,
      "message": "The counter part in renderengine is in \nhttps://android-review.googlesource.com/c/platform/frameworks/native/+/2135173\n\nThe issue appeared in libstagefright/renderfright only.",
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9e26ec2f_00bdec48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-07T18:50:10Z",
      "side": 1,
      "message": "How would you get overflow here since this only contains subtraction \u0026 division (and doesn\u0027t look to be dividing by a number \u003c1), and none of the inputs are highp either?",
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a4c6c2a0_a7e93323",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1071172
      },
      "writtenOn": "2022-07-08T15:56:29Z",
      "side": 1,
      "message": "Thanks for asking.\nTo share more information, I replied in https://partnerissuetracker.corp.google.com/u/1/issues/237997490.",
      "parentUuid": "9e26ec2f_00bdec48",
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6665ed1e_29f38c03",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-08T18:58:44Z",
      "side": 1,
      "message": "+media for OWNERs",
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "23f3b5aa_a39c55ca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1108919
      },
      "writtenOn": "2022-07-11T23:24:59Z",
      "side": 1,
      "message": "if my reasoning in my last comment holds, this is ok and my only suggestion is\nto add a comment about why we\u0027re bumping the range the slope calculation.  and perhaps bumping all of the slope calculations.",
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a9c8b90_0c27d7cd",
        "filename": "media/libstagefright/renderfright/gl/ProgramCache.cpp",
        "patchSetId": 1
      },
      "lineNbr": 377,
      "author": {
        "id": 1108919
      },
      "writtenOn": "2022-07-09T03:27:37Z",
      "side": 1,
      "message": "i\u0027m not totally familiar with how the lowp/mediump/highp primitives map out,\nand this is float not int....\n\nin an int world, we\u0027d do the calculations with y1, y0, x1, and x0 in sizes appropriate to their types (all are simple floats here). then we\u0027d worry about a cast to save a possibly more precise slope.\n\nso it makes me think that perhaps y1/y0/x1/x0 should be declared as or cast to a \u0027highp float\u0027 so that the calculation happens in the wider type.\n\nI realize that I come at this more from the C-on-a-cpu perspective and not so much the GLES perspective, but help me understand \"highp float\" vs \"double\".",
      "range": {
        "startLine": 377,
        "startChar": 36,
        "endLine": 377,
        "endChar": 78
      },
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aa3aa96e_5aa240eb",
        "filename": "media/libstagefright/renderfright/gl/ProgramCache.cpp",
        "patchSetId": 1
      },
      "lineNbr": 377,
      "author": {
        "id": 1071172
      },
      "writtenOn": "2022-07-11T15:13:48Z",
      "side": 1,
      "message": "Thanks for asking. The process of finding the cause is intriguing.\n\n- We once thought about making change like below, it could give wider coverage.\n\nhighp float nits \u003d color.y;\n\nBut consider to the unknown performance impact and try the least modification of solution, the change in the review only covers the issue found.\n\n- I don\u0027t know in detail of ToneMap. Since there are some mathematical expressions, thay may need to be checked in real cases whether it could exceed the max value of float.\n \n- highp\nLike other floating-point types, it follows spec of IEEE 754. More details, please refer to:\n\nhttps://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf\n4.5 Precision and Precision Qualifiers\nThe precision of highp floating-point variables is defined by the IEEE 754 standard for 32-bit floating-point numbers.",
      "parentUuid": "2a9c8b90_0c27d7cd",
      "range": {
        "startLine": 377,
        "startChar": 36,
        "endLine": 377,
        "endChar": 78
      },
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5da1590c_5bfd3790",
        "filename": "media/libstagefright/renderfright/gl/ProgramCache.cpp",
        "patchSetId": 1
      },
      "lineNbr": 377,
      "author": {
        "id": 1108919
      },
      "writtenOn": "2022-07-11T23:24:59Z",
      "side": 1,
      "message": "my reading says that \u0027highp float\u0027 is 32-bit ieee, so largest value about 10^38;\nit\u0027s not clear to me that \u0027float\u0027 and \u0027highp float\u0027 behave differently (at least from a 2 minute skim of that GLS document).\n\n32 bit ieee numbers go up to about 3*10^38.  (which is about 2^127)\n\nseems to me that if we\u0027re overflowing in here, it\u0027s likely that \u0027x1-x0\u0027 and y1-y0 differ by at least 10^38.  which sounds like a nearly vertical line; slope is always problematic in such cases.\n\n\nahh.... it appears that in renderfright/gl/ProgramCache.cpp and renderfright/gl/filters/BlurFilter.cpp, we do \"precision mediump float\", so all of the otherwise unadorned float variables become \"mediump float\"\n\nmediump has range of about 2^14\nhighp has range of about 2^127\n\nthat\u0027s what is getting me -- that the simple \u0027float\u0027 is really a mediump float and has a pretty restrictive range.\n\nmight be worth some comments in here as to why we need the extra range.",
      "parentUuid": "aa3aa96e_5aa240eb",
      "range": {
        "startLine": 377,
        "startChar": 36,
        "endLine": 377,
        "endChar": 78
      },
      "revId": "6e44c15ff7e35ffb6c29856c84ad7b62efd95f72",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}