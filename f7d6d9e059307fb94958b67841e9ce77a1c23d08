{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d30e6240_ff42e152",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1156740
      },
      "writtenOn": "2021-02-19T07:30:42Z",
      "side": 1,
      "message": "Sending usage with a new version HAL of IComponent::setOutputSurface could be a solution?  ",
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d52851a_b7bfd018",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2021-02-19T17:13:25Z",
      "side": 1,
      "message": "Yes, in fact I added that todo. The idea is that in HAL 1.2 the vendor side could set the consumer usage at the time the surface switch happens. There is still an inherent race if the component is allocating  in the background...",
      "parentUuid": "d30e6240_ff42e152",
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b1170bb_17589102",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2021-02-19T06:12:06Z",
      "side": 1,
      "message": "nit: delete",
      "range": {
        "startLine": 47,
        "startChar": 48,
        "endLine": 47,
        "endChar": 54
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7aebaa57_6fecb18a",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 86,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2021-02-19T06:12:06Z",
      "side": 1,
      "message": "nit: buffers",
      "range": {
        "startLine": 86,
        "startChar": 28,
        "endLine": 86,
        "endChar": 29
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ffa5540_8674aa6b",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1463,
      "author": {
        "id": 1018606
      },
      "writtenOn": "2021-02-25T17:46:44Z",
      "side": 1,
      "message": "nit: remove?",
      "range": {
        "startLine": 1463,
        "startChar": 7,
        "endLine": 1463,
        "endChar": 24
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "99e85cd3_b7940f7c",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1463,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2021-03-17T07:32:24Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7ffa5540_8674aa6b",
      "range": {
        "startLine": 1463,
        "startChar": 7,
        "endLine": 1463,
        "endChar": 24
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81b773f8_28e37c07",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1466,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2021-02-19T06:12:06Z",
      "side": 1,
      "message": "Vinay/Wonsik: should we default this to CPU_READ if we are not setting surface?",
      "range": {
        "startLine": 1466,
        "startChar": 12,
        "endLine": 1466,
        "endChar": 19
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc44fa36_9575cc90",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1466,
      "author": {
        "id": 1018606
      },
      "writtenOn": "2021-02-25T17:46:44Z",
      "side": 1,
      "message": "From MediaCodec\u0027s point of view, null surface means byte buffer mode... so yes, we\u0027d want CPU_READ.",
      "parentUuid": "81b773f8_28e37c07",
      "range": {
        "startLine": 1466,
        "startChar": 12,
        "endLine": 1466,
        "endChar": 19
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "311422dd_67e5d9c7",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1466,
      "author": {
        "id": 1021605
      },
      "writtenOn": "2021-03-17T07:32:24Z",
      "side": 1,
      "message": "I am no longer convinced that this is the case at the CCodec level. Today we do not allow setting surface to null once configured for surface mode, but exoPlayer team asked us to be able to do setSurface to null when the surface is hidden. In this case the buffers would simply not be rendered. This could be signaled using setSurface(null) while keeping buffer allocator as \"BQBBP\". This could also be signaled by setting buffer allocator to a new \"GRALLOC\" allocator. I don\u0027t think we are calling setSurface(null) in bytebuffer mode.",
      "parentUuid": "dc44fa36_9575cc90",
      "range": {
        "startLine": 1466,
        "startChar": 12,
        "endLine": 1466,
        "endChar": 19
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "708ff753_57299c41",
        "filename": "media/codec2/hidl/client/client.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1466,
      "author": {
        "id": 1156740
      },
      "writtenOn": "2021-03-24T12:43:21Z",
      "side": 1,
      "message": "HAL v1.2 setoutputsurfacewithsyncobj passes consumer usage.\n\nIGBP interface does not have getConsumerUsage() though BQ interface have it.\nIt is also possible to dequeue a random buffer and get consumer usage there,\nBut there is a slight possibility of failure due to cleaning up BQ is lingering.\n\n(I came across the issue when I try to get generation number by same logic.)",
      "parentUuid": "311422dd_67e5d9c7",
      "range": {
        "startLine": 1466,
        "startChar": 12,
        "endLine": 1466,
        "endChar": 19
      },
      "revId": "f7d6d9e059307fb94958b67841e9ce77a1c23d08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}