{
  "comments": [
    {
      "key": {
        "uuid": "e27a7932_3f5db8f3",
        "filename": "services/audioflinger/FastMixer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 390,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2016-03-02T01:41:22Z",
      "side": 1,
      "message": "I believe this only needs to be cleared if there are no tracks to mix (none are enabled).  We might be able to check this condition on line 412, and if mMixerBufferState is not ZEROED, set mMixerBufferState to UNDEFINED.  That should clear the buffer on line 419.\n\nGlenn would know better...",
      "range": {
        "startLine": 390,
        "startChar": 20,
        "endLine": 390,
        "endChar": 62
      },
      "revId": "64e8d0566cf5883c350dda9c69b05e4c28582599",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42318581_4ce258eb",
        "filename": "services/audioflinger/FastMixer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 390,
      "author": {
        "id": 1004395
      },
      "writtenOn": "2016-03-02T02:40:34Z",
      "side": 1,
      "message": "I am away from the full source code at the moment,\nso it is difficult for me to review this right now.\nHowever, the intention of mMixerBufferState is to keeo track\nof the state of the mix buffer, and to only zero it when necessary.\nWe definitely would want to keep that optimization to eliminate\nunnecessary zero operations. \n\nAgain, I\u0027m not seeing all the code, but it seems like\nit would be incorrect to clear the mix buffer for each track.\nIs this new code being executed for _every_ track\n(that is in underrun)?  And what happens if a previous\ntrack was not in underrun ... would we lose the previously\nmixed data? Either would be bad.",
      "parentUuid": "e27a7932_3f5db8f3",
      "range": {
        "startLine": 390,
        "startChar": 20,
        "endLine": 390,
        "endChar": 62
      },
      "revId": "64e8d0566cf5883c350dda9c69b05e4c28582599",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "02986d84_58e34ac2",
        "filename": "services/audioflinger/FastMixer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 390,
      "author": {
        "id": 1004395
      },
      "writtenOn": "2016-03-02T02:40:34Z",
      "side": 1,
      "message": "I am away from the full source code at the moment,\nso it is difficult for me to review this right now.\nHowever, the intention of mMixerBufferState is to keeo track\nof the state of the mix buffer, and to only zero it when necessary.\nWe definitely would want to keep that optimization to eliminate\nunnecessary zero operations. \n\nAgain, I\u0027m not seeing all the code, but it seems like\nit would be incorrect to clear the mix buffer for each track.\nIs this new code being executed for _every_ track\n(that is in underrun)?  And what happens if a previous\ntrack was not in underrun ... would we lose the previously\nmixed data? Either would be bad.",
      "parentUuid": "e27a7932_3f5db8f3",
      "range": {
        "startLine": 390,
        "startChar": 20,
        "endLine": 390,
        "endChar": 62
      },
      "revId": "64e8d0566cf5883c350dda9c69b05e4c28582599",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "02594de9_0e4d4c68",
        "filename": "services/audioflinger/FastMixer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 390,
      "author": {
        "id": 1003259
      },
      "writtenOn": "2016-03-02T02:54:37Z",
      "side": 1,
      "message": "If the logic is similar to the normal mixer, then we should clear the mix buffer only if all tracks are underruning because in this case the mixer process function will be a nop.\nTo answer Glenn\u0027s concern this takes place before the actual mixer process() so there is no risk to lose data from a previous track.",
      "parentUuid": "42318581_4ce258eb",
      "range": {
        "startLine": 390,
        "startChar": 20,
        "endLine": 390,
        "endChar": 62
      },
      "revId": "64e8d0566cf5883c350dda9c69b05e4c28582599",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "42034591_2c96f773",
        "filename": "services/audioflinger/FastMixer.cpp",
        "patchSetId": 1
      },
      "lineNbr": 390,
      "author": {
        "id": 1057645
      },
      "writtenOn": "2016-03-02T09:27:34Z",
      "side": 1,
      "message": "As eric mentioned any data loss will not happen in this case because mixer-\u003eprocess() gets called after processing all the tracks. So memset will happen before actual mixing happens.\n\nBut yes if there are possibility of unnecessary memset() operations with this change.\n\nProblem is we can\u0027t just set mMixerBufferState to UNDEFINED when there is a underrun for a track, since some other track may have ready data.\n\nMy suggestion to avoid extra memset is :\n\n\u003d\u003e Add a new MixerBufferState as READY\n\u003d\u003e Set mMixerBufferState to UNDEFINED at start of every onWork() loop. Set mMixerBufferState to READY if for any track data is available.\n\u003d\u003e Call mixer-\u003eprocess() only if mMixerBufferState is READY.\n\nLet me know how this sounds. If you agree i will update the commit.",
      "parentUuid": "02594de9_0e4d4c68",
      "range": {
        "startLine": 390,
        "startChar": 20,
        "endLine": 390,
        "endChar": 62
      },
      "revId": "64e8d0566cf5883c350dda9c69b05e4c28582599",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}