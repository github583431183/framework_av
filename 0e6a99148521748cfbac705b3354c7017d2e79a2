{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "cc7dd363_f03ad5b0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2022-09-01T04:54:52Z",
      "side": 1,
      "message": "Hmm.... I wonder why casting from listener2.0 to listener2.1 doesn\u0027t work in this case? Isn\u0027t listener2.1 derived from listener2.0?",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d730b29_fe5d8257",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-01T06:57:46Z",
      "side": 1,
      "message": "Casting from listener2.0 to listener2.1 works in this case, but Casting is a block hidl call.\n\nIssue we met was two clients almost calling disconnect at the same time, when we call disconnect, hal will flush requests and notify the results are in errors state.And the onDeviceError is a block hidl, it will acquire Mutex::Autolock _l(dev-\u003emDeviceLock), but disconnect would hold this Mutex.\n\nWhen onPhysicalCameraStatusChanged is a block hidl call, it will blocked by onDeviceError, so the first disconnect will be blocked by interfaceChain in casting.\n\nAt the same time, the second disconnection is waiting for completing of the first disconnection and blocking onDeviceError.",
      "parentUuid": "cc7dd363_f03ad5b0",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54c2e636_3d7cab8c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2022-09-01T19:11:36Z",
      "side": 1,
      "message": "```\nWhen onPhysicalCameraStatusChanged is a block hidl call, it will blocked by onDeviceError, so the first disconnect will be blocked by interfaceChain in casting.\n```\n\nSorry, Why is this true ? why does onDeviceError from client 1 block a binder call from client 2 from progressing ?",
      "parentUuid": "3d730b29_fe5d8257",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edd07f5f_a18119d0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-02T02:45:04Z",
      "side": 1,
      "message": "Client 1 call disconnect and notify Client 2 physical camera status has been changed with onPhysicalCameraStatusChanged.\n\nAnd Client 2 call disconnect and flush error requests, and then receive \nhidl notification onDeviceError.\n\nSo disconnection of client 2 hold mDeviceLock and onDeviceError acquire it, onDeviceError wait for client 2 disconnect.\n\nClient 2 disconnect wait client 1 disconnect, client 1 wait for onPhysicalCameraStatusChanged, onPhysicalCameraStatusChanged wait onDeviceError, onDeviceError wait Client 2 disconnect.\n\nAn perfetto trace is attached in Customer Issue: 243902566, It will visually shows you this deadlock.",
      "parentUuid": "54c2e636_3d7cab8c",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78dce71c_9e2d4685",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-02T07:55:01Z",
      "side": 1,
      "message": "https://doc-2n60-038g-partnerissuetracker.corp.googleusercontent.com/attachments/306dmj7tk1s8m5bvjcultmm13cr6es3g/36s72719mr2aar054rd23tkdfufmkqmk/1662104700000/661552/104712268089853411877/243902566::38648553::661552?dat\u003dAFNnbnmNv0KaALeWJcnmP8cLxpjpd2TvFt1SHx8sF0rsh40zuugtFq_m_4FWeS1OP8gpLmXvIShATT6-Ry0WqnJvUr5h4BIrGKhRSojaln82gmtNWF66dd2_y3zE8C2Evuja6MNmOWH8y7gpkMtanOFsppiwfem2ruiH2cGWMzQpuf3JQib3763dQf0gk7lW6Wyr09LVbcgwvE-LpUjdI70-WpjWYgCTbaVRyi-F7QbXHnb-n88sDLxzmvOcg9wYzYolQ7qmt8gFc2EVAFgUcfpEyVArkI0JogYYBhEws1gM2sow_sw2BTOlS4iaSyg7A3Rz4v5zSf-3J5MneCbTfGaF5U6DRXgmPl6BpElH-4s-1Me0P4RF_UZy1DiJB1BpbUeVTmZH5yZ8yC0adFunAYpjrcwcOuE2QJ590pcBMiyTyC1DPMd4JlSmXMar8ushxYL4Z8AAbHZqP1DKtOim-amaSQFo6mLlc-KgN4CIMkR_VjDj6UQo3gX9j7_c6mTWqzbmxwZVD4q0AmSSfHK9_PVS9-ihjh6Pc-FLyOtKFGiLSc-TqHAgUamg200zFsXeq_skEo0Z4drdGEqRuCWNxRXMGJc6r-96iMP4BkjDGn9KuaWfbFWWROSgo2R0CIT-I86KN9HtChor1KYY6ftOR-jo3Lf6cgMkv1aXWvKtiEc3R95dR5fip1Hfc_2yEk5QmEg_brVXkCPszknV1CQQwZOZabfkyu_ZNhDJufSSUNABhGZjY8-EJpSuG27JNmYEDPgmH-AgkCXD\u0026u\u003d0\u0026s\u003d1\u0026q\u003dAN9yeQLibLxc41u2JOcaRmk2MYNYIeT5tgcOP-v721E-rF3S1Udj_mYUN9Jn2KYTxU-0e5KOczBW7BPKtmZXLtLXVfUpaQ\u0026download\u003dfalse\u0026nonce\u003din3afu33hsa9c\u0026user\u003d104712268089853411877\u0026hash\u003d6gm38j7hubtigq44ir49bd0td5qcg36c",
      "parentUuid": "edd07f5f_a18119d0",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "15580851_e37003d2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-08T12:33:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "78dce71c_9e2d4685",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ab104aa_9fdb91d2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2022-09-13T05:11:22Z",
      "side": 1,
      "message": "Hi,\nfrom your previous comment\n\u003e onPhysicalCameraStatusChanged wait onDeviceError\n\nMy question still stands, why is this true ? onPhysicalCameraStatusChanged is a binder call into client 2, so is onDeviceError. But why is onPhysicalCameraStatusChanged blocked by onDeviceError ? Are there not enough hwbinder threads in client 2 ?  \n\nI tried looking at the perfetto trace, it can get slightly harder to reason with since it only shows trace points (which all functions don\u0027t have). If the deadlock is reproducible is it possible for you to capture stack traces for both cameraserver and the client processes by doing :\nadb shell debuggerd -b \u003cpid\u003e\n\nThat way we\u0027ll have a clearer understanding of where exactly the deadlock is happening. \n\nThanks",
      "parentUuid": "15580851_e37003d2",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db50dd2f_3df2c455",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2023-03-23T09:12:43Z",
      "side": 1,
      "message": "Hi,\nWe did further analysis, for the hwbinder thread pool is start by addListener, and default thread number of hwbinder is 0. So the only one hwbinder thread exists.\n\nFor the service use aidl in default, it won\u0027t start hwbinder threads pook and setting thread numbers in main function.",
      "parentUuid": "7ab104aa_9fdb91d2",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9238924d_fd18402f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2023-03-23T09:17:45Z",
      "side": 1,
      "message": "Hi,\nThis patch make oneway call become true oneway call. It makes no side effect. Please help review, thks.",
      "parentUuid": "db50dd2f_3df2c455",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69352f00_ad1cc609",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2023-03-29T02:25:02Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9238924d_fd18402f",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74827f0b_70bf2235",
        "filename": "services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2022-09-01T04:54:52Z",
      "side": 1,
      "message": "Do you mean this cast would deadlock? I wonder if it\u0027s expected for ::castFrom to block.",
      "range": {
        "startLine": 47,
        "startChar": 17,
        "endLine": 47,
        "endChar": 52
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3607cd32_5e024932",
        "filename": "services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-01T06:57:46Z",
      "side": 1,
      "message": "Yes, ::castFrom will cause dealock. It\u0027s expected for ::castFrom to block when the listener added is 2.0. But when we add listener 2.1, this cast is not necessary, and the blocking is not excepted.\n\nCastFrom call flow as follows:\n\n::android::hardware::Return\u003c::android::sp\u003c::android::frameworks::cameraservice::service::V2_1::ICameraServiceListener\u003e\u003e ICameraServiceListener::castFrom(const ::android::sp\u003c::android::frameworks::cameraservice::service::V2_1::ICameraServiceListener\u003e\u0026 parent, bool /* emitError */) {\n    return parent;\n}\n\n::android::hardware::Return\u003c::android::sp\u003c::android::frameworks::cameraservice::service::V2_1::ICameraServiceListener\u003e\u003e ICameraServiceListener::castFrom(const ::android::sp\u003c::android::frameworks::cameraservice::service::V2_0::ICameraServiceListener\u003e\u0026 parent, bool emitError) {\n    return ::android::hardware::details::castInterface\u003cICameraServiceListener, ::android::frameworks::cameraservice::service::V2_0::ICameraServiceListener, BpHwCameraServiceListener\u003e(\n            parent, \"android.frameworks.cameraservice.service@2.1::ICameraServiceListener\", emitError);\n}\n\n\n\n\nReturn\u003csp\u003cIChild\u003e\u003e castInterface(sp\u003cIParent\u003e parent, const char* childIndicator, bool emitError) {\n    if (parent.get() \u003d\u003d nullptr) {\n        // casts always succeed with nullptrs.\n        return nullptr;\n    }\n    Return\u003cbool\u003e canCastRet \u003d details::canCastInterface(parent.get(), childIndicator, emitError);\n    if (!canCastRet.isOk()) {\n        // call fails, propagate the error if emitError\n        return emitError\n                ? details::StatusOf\u003cbool, sp\u003cIChild\u003e\u003e(canCastRet)\n                : Return\u003csp\u003cIChild\u003e\u003e(sp\u003cIChild\u003e(nullptr));\n    }\n\n    if (!canCastRet) {\n        return sp\u003cIChild\u003e(nullptr); // cast failed.\n    }\n    // TODO b/32001926 Needs to be fixed for socket mode.\n    if (parent-\u003eisRemote()) {\n        // binderized mode. Got BpChild. grab the remote and wrap it.\n        return sp\u003cIChild\u003e(new BpChild(getOrCreateCachedBinder(parent.get())));\n    }\n    // Passthrough mode. Got BnChild or BsChild.\n    return sp\u003cIChild\u003e(static_cast\u003cIChild *\u003e(parent.get()));\n}\n\n\n\n\nAnd then canCastInterface call interfaceChain, interfaceChain is not a oneway binder, it will cause blocking in hidl.\n\n\n\n\nReturn\u003cbool\u003e canCastInterface(IBase* interface, const char* castTo, bool emitError) {\n    if (interface \u003d\u003d nullptr) {\n        return false;\n    }\n\n    // b/68217907\n    // Every HIDL interface is a base interface.\n    if (std::string(IBase::descriptor) \u003d\u003d castTo) {\n        return true;\n    }\n\n    bool canCast \u003d false;\n    auto chainRet \u003d interface-\u003einterfaceChain([\u0026](const hidl_vec\u003chidl_string\u003e \u0026types) {\n        for (size_t i \u003d 0; i \u003c types.size(); i++) {\n            if (types[i] \u003d\u003d castTo) {\n                canCast \u003d true;\n                break;\n            }\n        }\n    });\n\n    if (!chainRet.isOk()) {\n        // call fails, propagate the error if emitError\n        return emitError\n                ? details::StatusOf\u003cvoid, bool\u003e(chainRet)\n                : Return\u003cbool\u003e(false);\n    }\n\n    return canCast;\n}",
      "parentUuid": "74827f0b_70bf2235",
      "range": {
        "startLine": 47,
        "startChar": 17,
        "endLine": 47,
        "endChar": 52
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca592c19_b02b803d",
        "filename": "services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-08T12:33:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3607cd32_5e024932",
      "range": {
        "startLine": 47,
        "startChar": 17,
        "endLine": 47,
        "endChar": 52
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}