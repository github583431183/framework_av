{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "cc7dd363_f03ad5b0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2022-09-01T04:54:52Z",
      "side": 1,
      "message": "Hmm.... I wonder why casting from listener2.0 to listener2.1 doesn\u0027t work in this case? Isn\u0027t listener2.1 derived from listener2.0?",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d730b29_fe5d8257",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-01T06:57:46Z",
      "side": 1,
      "message": "Casting from listener2.0 to listener2.1 works in this case, but Casting is a block hidl call.\n\nIssue we met was two clients almost calling disconnect at the same time, when we call disconnect, hal will flush requests and notify the results are in errors state.And the onDeviceError is a block hidl, it will acquire Mutex::Autolock _l(dev-\u003emDeviceLock), but disconnect would hold this Mutex.\n\nWhen onPhysicalCameraStatusChanged is a block hidl call, it will blocked by onDeviceError, so the first disconnect will be blocked by interfaceChain in casting.\n\nAt the same time, the second disconnection is waiting for completing of the first disconnection and blocking onDeviceError.",
      "parentUuid": "cc7dd363_f03ad5b0",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54c2e636_3d7cab8c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1121338
      },
      "writtenOn": "2022-09-01T19:11:36Z",
      "side": 1,
      "message": "```\nWhen onPhysicalCameraStatusChanged is a block hidl call, it will blocked by onDeviceError, so the first disconnect will be blocked by interfaceChain in casting.\n```\n\nSorry, Why is this true ? why does onDeviceError from client 1 block a binder call from client 2 from progressing ?",
      "parentUuid": "3d730b29_fe5d8257",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edd07f5f_a18119d0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-02T02:45:04Z",
      "side": 1,
      "message": "Client 1 call disconnect and notify Client 2 physical camera status has been changed with onPhysicalCameraStatusChanged.\n\nAnd Client 2 call disconnect and flush error requests, and then receive \nhidl notification onDeviceError.\n\nSo disconnection of client 2 hold mDeviceLock and onDeviceError acquire it, onDeviceError wait for client 2 disconnect.\n\nClient 2 disconnect wait client 1 disconnect, client 1 wait for onPhysicalCameraStatusChanged, onPhysicalCameraStatusChanged wait onDeviceError, onDeviceError wait Client 2 disconnect.\n\nAn perfetto trace is attached in Customer Issue: 243902566, It will visually shows you this deadlock.",
      "parentUuid": "54c2e636_3d7cab8c",
      "range": {
        "startLine": 10,
        "startChar": 0,
        "endLine": 10,
        "endChar": 59
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74827f0b_70bf2235",
        "filename": "services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2022-09-01T04:54:52Z",
      "side": 1,
      "message": "Do you mean this cast would deadlock? I wonder if it\u0027s expected for ::castFrom to block.",
      "range": {
        "startLine": 47,
        "startChar": 17,
        "endLine": 47,
        "endChar": 52
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3607cd32_5e024932",
        "filename": "services/camera/libcameraservice/hidl/AidlCameraServiceListener.cpp",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1965242
      },
      "writtenOn": "2022-09-01T06:57:46Z",
      "side": 1,
      "message": "Yes, ::castFrom will cause dealock. It\u0027s expected for ::castFrom to block when the listener added is 2.0. But when we add listener 2.1, this cast is not necessary, and the blocking is not excepted.\n\nCastFrom call flow as follows:\n\n::android::hardware::Return\u003c::android::sp\u003c::android::frameworks::cameraservice::service::V2_1::ICameraServiceListener\u003e\u003e ICameraServiceListener::castFrom(const ::android::sp\u003c::android::frameworks::cameraservice::service::V2_1::ICameraServiceListener\u003e\u0026 parent, bool /* emitError */) {\n    return parent;\n}\n\n::android::hardware::Return\u003c::android::sp\u003c::android::frameworks::cameraservice::service::V2_1::ICameraServiceListener\u003e\u003e ICameraServiceListener::castFrom(const ::android::sp\u003c::android::frameworks::cameraservice::service::V2_0::ICameraServiceListener\u003e\u0026 parent, bool emitError) {\n    return ::android::hardware::details::castInterface\u003cICameraServiceListener, ::android::frameworks::cameraservice::service::V2_0::ICameraServiceListener, BpHwCameraServiceListener\u003e(\n            parent, \"android.frameworks.cameraservice.service@2.1::ICameraServiceListener\", emitError);\n}\n\n\n\n\nReturn\u003csp\u003cIChild\u003e\u003e castInterface(sp\u003cIParent\u003e parent, const char* childIndicator, bool emitError) {\n    if (parent.get() \u003d\u003d nullptr) {\n        // casts always succeed with nullptrs.\n        return nullptr;\n    }\n    Return\u003cbool\u003e canCastRet \u003d details::canCastInterface(parent.get(), childIndicator, emitError);\n    if (!canCastRet.isOk()) {\n        // call fails, propagate the error if emitError\n        return emitError\n                ? details::StatusOf\u003cbool, sp\u003cIChild\u003e\u003e(canCastRet)\n                : Return\u003csp\u003cIChild\u003e\u003e(sp\u003cIChild\u003e(nullptr));\n    }\n\n    if (!canCastRet) {\n        return sp\u003cIChild\u003e(nullptr); // cast failed.\n    }\n    // TODO b/32001926 Needs to be fixed for socket mode.\n    if (parent-\u003eisRemote()) {\n        // binderized mode. Got BpChild. grab the remote and wrap it.\n        return sp\u003cIChild\u003e(new BpChild(getOrCreateCachedBinder(parent.get())));\n    }\n    // Passthrough mode. Got BnChild or BsChild.\n    return sp\u003cIChild\u003e(static_cast\u003cIChild *\u003e(parent.get()));\n}\n\n\n\n\nAnd then canCastInterface call interfaceChain, interfaceChain is not a oneway binder, it will cause blocking in hidl.\n\n\n\n\nReturn\u003cbool\u003e canCastInterface(IBase* interface, const char* castTo, bool emitError) {\n    if (interface \u003d\u003d nullptr) {\n        return false;\n    }\n\n    // b/68217907\n    // Every HIDL interface is a base interface.\n    if (std::string(IBase::descriptor) \u003d\u003d castTo) {\n        return true;\n    }\n\n    bool canCast \u003d false;\n    auto chainRet \u003d interface-\u003einterfaceChain([\u0026](const hidl_vec\u003chidl_string\u003e \u0026types) {\n        for (size_t i \u003d 0; i \u003c types.size(); i++) {\n            if (types[i] \u003d\u003d castTo) {\n                canCast \u003d true;\n                break;\n            }\n        }\n    });\n\n    if (!chainRet.isOk()) {\n        // call fails, propagate the error if emitError\n        return emitError\n                ? details::StatusOf\u003cvoid, bool\u003e(chainRet)\n                : Return\u003cbool\u003e(false);\n    }\n\n    return canCast;\n}",
      "parentUuid": "74827f0b_70bf2235",
      "range": {
        "startLine": 47,
        "startChar": 17,
        "endLine": 47,
        "endChar": 52
      },
      "revId": "0e6a99148521748cfbac705b3354c7017d2e79a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}