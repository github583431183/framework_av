{
  "comments": [
    {
      "key": {
        "uuid": "90acdb8c_b8ee4a17",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-10T18:21:00Z",
      "side": 1,
      "message": "I suggest to change the wording in order to fully describe the problem and the solution. Proposed description:\n\n\"When the Visualizer effect is released, synchronous wait for the CaptureThread can cause ANR in an app. This is why an asynchronous \u0027release\u0027 method is introduced which is used by Visualizer.release() method on the Java side. Since CaptureThread may still be running while the the last reference to the Visualizer instance is released, CaptureThread now holds a strong reference to the Visualizer, which it releases upon exit from the thread loop.\n\n\u0027release\u0027 method does not check for \u0027enabled\u0027 status because setEnabled(false) may fail due to ??? [please explain what \"we don\u0027t grant control\" means]\"",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 19,
        "endChar": 0
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edcde4cb_f6d76f16",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 66,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-10T18:21:00Z",
      "side": 1,
      "message": "Add a comment here that this is intentionally asynchronous to avoid causing an ANR in the app if CaptureThread is slow to exit.",
      "range": {
        "startLine": 66,
        "startChar": 8,
        "endLine": 66,
        "endChar": 38
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dfd8998c_b0dcb621",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-08T18:27:08Z",
      "side": 1,
      "message": "If we call \u0027clear\u0027 here, thus freeing up the instance of \u0027CaptureThread\u0027 class, while the thread hasn\u0027t been terminated execution yet, it means CaptureThread::threadLoop() will attempt to access memory that has been freed. That\u0027s why it\u0027s important to wait for the thread to join. That\u0027s why I was asking to use \u0027setCaptureCallback\u0027 which handles thread termination correctly.",
      "range": {
        "startLine": 69,
        "startChar": 4,
        "endLine": 69,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d4716a81_61d8f957",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1143570
      },
      "writtenOn": "2018-10-09T11:57:27Z",
      "side": 1,
      "message": "We should not clear here, mCaptureThread should be clear in the destructor. I will fix it later",
      "parentUuid": "dfd8998c_b0dcb621",
      "range": {
        "startLine": 69,
        "startChar": 4,
        "endLine": 69,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd2d56c4_04be3119",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-10T18:21:00Z",
      "side": 1,
      "message": "Since \u0027threadLoop\u0027 holds a strong reference, clearing mCaptureThread will not release it, so it\u0027s OK to clear it here.",
      "parentUuid": "d4716a81_61d8f957",
      "range": {
        "startLine": 69,
        "startChar": 4,
        "endLine": 69,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6576ca8c_7c979024",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 433,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-08T18:27:08Z",
      "side": 1,
      "message": "Please do not create an sp\u003c\u003e scoped at whole lifetime of the thread. This is roughly equivalent to having an sp\u003c\u003e as a data member of CaptureThread class. You need to attempt to promote a wp\u003c\u003e to sp\u003c\u003e in a very limited scope--when you are attempting to call \u0027periodicCapture\u0027. You also need to check whether wp\u003c\u003e::promote returns a non-null pointer. Please consult the documentation in the beginning of system/core/libutils/include/utils/RefBase.h.",
      "range": {
        "startLine": 433,
        "startChar": 4,
        "endLine": 433,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "207d8d5a_23f445cb",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 433,
      "author": {
        "id": 1143570
      },
      "writtenOn": "2018-10-09T11:57:27Z",
      "side": 1,
      "message": "If we promote a wp\u003c\u003e to sp\u003c\u003e before calling \u0027periodicCapture\u0027, there may also be native crash. The Visulalizer may have been decStrong in jni before promote in threadLoop, then destructor will be called. At the same time, we promte the wp\u003c\u003e to sp\u003c\u003e before the end of destructor, wp\u003c\u003e::promote returns a non-null pointer and periodicCapture also will be called after destroy.\nActually we could reproduce this issue with our device. After move promote to while loop, the probability of this issue reduce, but it still happen.",
      "parentUuid": "6576ca8c_7c979024",
      "range": {
        "startLine": 433,
        "startChar": 4,
        "endLine": 433,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "82f3011c_37904865",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 433,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-09T17:39:32Z",
      "side": 1,
      "message": "OK, so you are trying to prevent a crash by making sure that the instance of Visualizer does not get destroyed while the thread is running.\n\nAs I understand from the CL description, the Visualizer destructor may avoid finishing the CaptureThread if \u0027setEnabled\u0027 call in the destructor has failed, thus leaving \u0027mEnabling\u0027 status to be \u0027true\u0027. To me, it seems more logical to fix that problem in the first place. For example, split out a private helper function from \u0027setCaptureCallBack\u0027 that takes care of stopping the thread, regardless of \u0027mEnabled\u0027 state. If stopping the thread is done synchronously (with \u0027requestExitAndWait\u0027), this will ensure that the thread will not outlive its Visualizer instance.\n\nThis is how this could be done, hopefully without the need make any other changes:\n\n    Visualizer::~Visualizer()\n    {\n        ALOGV(\"Visualizer::~Visualizer()\");\n        setEnabled(false);\n        Mutex::Autolock _l(mCaptureLock);\n        // This ensures that the capture thread exits before we leave the destructor.\n        stopCaptureCallBack_l();\n    }\n\n    // private\n    status_t Visualizer::stopCaptureCallBack_l()\n    {\n        if (mCaptureThread !\u003d 0) {\n            mCaptureLock.unlock();\n            mCaptureThread-\u003erequestExitAndWait();\n            mCaptureLock.lock();\n        }\n\n        mCaptureThread.clear();\n        mCaptureCallBack \u003d nullptr;\n        return NO_ERROR;\n    }\n\n    status_t Visualizer::setCaptureCallBack(capture_cbk_t cbk, void* user, uint32_t flags,\n            uint32_t rate)\n    {\n        if (rate \u003e CAPTURE_RATE_MAX) {\n            return BAD_VALUE;\n        }\n        Mutex::Autolock _l(mCaptureLock);\n\n        if (mEnabled) {\n            return INVALID_OPERATION;\n        }\n\n        stopCaptureCallBack_l();\n        mCaptureCallBack \u003d cbk;\n        mCaptureCbkUser \u003d user;\n        mCaptureFlags \u003d flags;\n        mCaptureRate \u003d rate;\n\n        if (cbk !\u003d NULL) {\n            mCaptureThread \u003d new CaptureThread(*this, rate, ((flags \u0026 CAPTURE_CALL_JAVA) !\u003d 0));\n        }\n        ALOGV(\"setCaptureCallBack() rate: %d thread %p flags 0x%08x\",\n                rate, mCaptureThread.get(), mCaptureFlags);\n        return NO_ERROR;\n    }",
      "parentUuid": "207d8d5a_23f445cb",
      "range": {
        "startLine": 433,
        "startChar": 4,
        "endLine": 433,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1fe642e_7afa5477",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 433,
      "author": {
        "id": 1143570
      },
      "writtenOn": "2018-10-10T01:50:08Z",
      "side": 1,
      "message": "Hi MikHail,\n   We tried to fix it like your comment (call requestExitAndWait in the destructor) a long time ago. It works, and native crash would not happen. But APP which call Visualizer::release may ANR, because periodicCapture may take a long time which result in requestExitAndWait failing to return immediatly.",
      "parentUuid": "82f3011c_37904865",
      "range": {
        "startLine": 433,
        "startChar": 4,
        "endLine": 433,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5ed27d5f_677198b1",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 433,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-10T18:21:00Z",
      "side": 1,
      "message": "Ah, I apologize, I was unaware of this attempt. Now I understand the reasoning for your approach completely.",
      "parentUuid": "b1fe642e_7afa5477",
      "range": {
        "startLine": 433,
        "startChar": 4,
        "endLine": 433,
        "endChar": 27
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a1751ef_833131c3",
        "filename": "media/libmedia/Visualizer.cpp",
        "patchSetId": 3
      },
      "lineNbr": 433,
      "author": {
        "id": 1042638
      },
      "writtenOn": "2018-10-10T18:21:00Z",
      "side": 1,
      "message": "Still need to add a check that receiver is not nullptr after promotion--in case if Visualizer got deleted before the thread actually started. In this case we should just exit the thread.",
      "range": {
        "startLine": 433,
        "startChar": 30,
        "endLine": 433,
        "endChar": 50
      },
      "revId": "efcae22997bf46dcb851b5c4acc02b704a337c4e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}