{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e2170ad8_9d7b76c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-25T18:24:53Z",
      "side": 1,
      "message": "Partner verified",
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6681fb45_21813dc9",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2023-08-26T00:55:43Z",
      "side": 1,
      "message": "What\u0027s the reason for only setting waitForIdleFence in the `else` clause, in other words, when `newState \u003d\u003d prevState`?",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e77ca6b_3572a259",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-28T16:01:04Z",
      "side": 1,
      "message": "This happens when we have a valid idle fence that is not signaled before \u0027getDeviceStateLocked\u0027. Currently we will go back and wait on the \"        mPendingChangeSignal\" for kWaitDuration without the ability to interrupt the wait. If \"validFence \u0026\u0026 !waitForIdleFence\" is true then we know that at some point the fence will be signaled and the state will change.",
      "parentUuid": "6681fb45_21813dc9",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b79f83a_2107d11d",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2023-08-28T21:14:59Z",
      "side": 1,
      "message": "My question is why don\u0027t we have something like:\n\n```\nif (newState !\u003d prevState) {\n    mStateTransitions.add(newState);\n}\n\nif (validFence \u0026\u0026 !waitForIdleFence) {\n    waitForIdleFence \u003d true;\n}\n```",
      "parentUuid": "4e77ca6b_3572a259",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb5aca63_66c1e9d6",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-28T21:22:20Z",
      "side": 1,
      "message": "If we have a state transition or in other words \"newState !\u003d prevState\", then we will be able to notify the parent at line #229 and the \"mPendingChangeSignal\" wait will be signaled and we will avoid an extra kWaitDuration latency. The only scenario where we want to wait on the idle fence is when we don\u0027t have a state transition along with valid fence.",
      "parentUuid": "0b79f83a_2107d11d",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48db4305_ce0ddd30",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2023-08-28T22:41:29Z",
      "side": 1,
      "message": "Thanks for the explanation!\n\nDoes this mean for ACTIVE-\u003eIDLE transition, we need an ACTIVE-\u003eIDLE-\u003eIDLE transition, so that the IDLE-\u003eIDLE transition can trigger waitForIdleFence?",
      "parentUuid": "eb5aca63_66c1e9d6",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e98c039_b45251bf",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-28T22:46:53Z",
      "side": 1,
      "message": "Sort of, it appears that depending on the timing of the idle fence signal, the ACTIVE-\u003eIDLE transition can be delayed just enough to miss \u0027getDeviceStateLocked\u0027 on line #206 and end up waiting one extra iteration for the \u0027mPendingChangeSignal\u0027 to timeout. So essentially we transition from ACTIVE to IDLE once however the parent may need to wait an extra \u0027kWaitDuration\u0027 to get notified.",
      "parentUuid": "48db4305_ce0ddd30",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "beb31ee2_83d453c6",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2023-08-28T23:20:44Z",
      "side": 1,
      "message": "So the below sequence can in theory still happen?\n\n```\n1. tracker.addComponent(1);\n2. tracker.markComponentActive(1);\n3. tracker.markComponentIdle(1, fence);\n4. // some time later\n   fence.signal();\n```\n\nIn this case, because there is no IDLE-\u003eIDLE transition, the extra kWaitDuration wait is still there?",
      "parentUuid": "7e98c039_b45251bf",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7172796d_a13689e3",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-28T23:28:47Z",
      "side": 1,
      "message": "Right, the possible optimization here is only useful/relevant in one particular case, when the fence is delayed between \"getDeviceStateLocked\" and kWaitDuration. If we timeout waiting on the fence, we resume as usual.",
      "parentUuid": "beb31ee2_83d453c6",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b910e6c_d711bf7e",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2023-08-29T01:07:36Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "7172796d_a13689e3",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}