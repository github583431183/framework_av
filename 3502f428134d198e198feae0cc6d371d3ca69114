{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e2170ad8_9d7b76c6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-25T18:24:53Z",
      "side": 1,
      "message": "Partner verified",
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6681fb45_21813dc9",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2023-08-26T00:55:43Z",
      "side": 1,
      "message": "What\u0027s the reason for only setting waitForIdleFence in the `else` clause, in other words, when `newState \u003d\u003d prevState`?",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e77ca6b_3572a259",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-28T16:01:04Z",
      "side": 1,
      "message": "This happens when we have a valid idle fence that is not signaled before \u0027getDeviceStateLocked\u0027. Currently we will go back and wait on the \"        mPendingChangeSignal\" for kWaitDuration without the ability to interrupt the wait. If \"validFence \u0026\u0026 !waitForIdleFence\" is true then we know that at some point the fence will be signaled and the state will change.",
      "parentUuid": "6681fb45_21813dc9",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b79f83a_2107d11d",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1092583
      },
      "writtenOn": "2023-08-28T21:14:59Z",
      "side": 1,
      "message": "My question is why don\u0027t we have something like:\n\n```\nif (newState !\u003d prevState) {\n    mStateTransitions.add(newState);\n}\n\nif (validFence \u0026\u0026 !waitForIdleFence) {\n    waitForIdleFence \u003d true;\n}\n```",
      "parentUuid": "4e77ca6b_3572a259",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb5aca63_66c1e9d6",
        "filename": "services/camera/libcameraservice/device3/StatusTracker.cpp",
        "patchSetId": 2
      },
      "lineNbr": 209,
      "author": {
        "id": 1141048
      },
      "writtenOn": "2023-08-28T21:22:20Z",
      "side": 1,
      "message": "If we have a state transition or in other words \"newState !\u003d prevState\", then we will be able to notify the parent at line #229 and the \"mPendingChangeSignal\" wait will be signaled and we will avoid an extra kWaitDuration latency. The only scenario where we want to wait on the idle fence is when we don\u0027t have a state transition along with valid fence.",
      "parentUuid": "0b79f83a_2107d11d",
      "range": {
        "startLine": 209,
        "startChar": 18,
        "endLine": 209,
        "endChar": 22
      },
      "revId": "3502f428134d198e198feae0cc6d371d3ca69114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}